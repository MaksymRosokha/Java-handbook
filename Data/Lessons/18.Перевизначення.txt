У попередньому уроці ми розповіли про суперкласи та підкласи. Якщо клас успадковує метод зі свого суперкласу, тоді є шанс перевизначити взятий метод, якщо він не помічений на final.

Так що таке Java overriding або override - це перевизначення.

Перевага в Java перевизначення полягає в тому, що воно дозволяє визначати (описувати) поведінку, характерну для типу підкласу, отже, підклас може реалізувати метод батьківського класу на основі його вимоги.

В об'єктно-орієнтованих термінах перевизначення означає перезапис функціоналу існуючого методу.


		~Приклад 1
Розглянемо приклад.

class Animal {
   public void move() {
      System.out.println("Тварини можуть рухатися");
   }
}

class Dog extends Animal {
   public void move() {
      System.out.println("Собаки можуть ходити та бігати");
   }
}

public class TestDog ​​{

   public static void main(String args[]) {
      Animal a = new Animal(); // Animal - посилання та об'єкт
      Animal b = New Dog (); // Animal – посилання, але Dog – об'єкт

      a.move(); // Запускає метод у класі Animal
      b.move(); // Запускає метод у класі Dog
   }
}

Після запуску програми буде видано такий результат:

Тварини можуть рухатися
Собаки можуть ходити та бігати

У наведеному вище прикладі ви можете помітити, що b є типом Animal, воно запускає метод move в класі Dog. Причина цього: під час компіляції відбувається перевірка типу посилання. Однак, під час виконання JVM визначає тип об'єкта і запускає метод, який належить цьому конкретному об'єкту.

Отже, за прикладом вище програма запуститься правильно, оскільки клас Animal має метод move. Потім під час виконання він запускає метод, що належить цьому об'єкту.

Розгляньте наступний приклад:


		~Приклад 2

class Animal {
   public void move() {
      System.out.println("Тварини можуть рухатися");
   }
}

class Dog extends Animal {
   public void move() {
      System.out.println("Собаки можуть ходити та бігати");
   }
   public void bark() {
      System.out.println("Собаки можуть гавкати");
   }
}

public class TestDog ​​{

   public static void main(String args[]) {
      Animal a = new Animal(); // Animal - посилання та об'єкт
      Animal b = New Dog (); // Animal – посилання, але Dog – об'єкт

      a.move(); // Запускає метод у класі Animal
      b.move(); // Запускає метод у класі Dog
      b.bark();
   }
}

Після запуску програми буде видано такий результат:

TestDog.java:26: error: cannot find symbol
      b.bark();
       ^
  symbol: method bark()
  location: variable b of type Animal
1 error

Програма видасть помилку під час компіляції, оскільки тип посилання b у Animal не має методу під ім'ям bark.

		~Правила перевизначення методу
•Список аргументів має бути таким самим, як і для перевизначеного методу.
•Повертаний тип повинен бути таким же або підтипом повертаючого типу, об'явленого у вихідному перевизначеному методі в суперкласі.
•Рівень доступу може бути обмеженішим, ніж рівень доступу перевизначеного методу. Наприклад, якщо метод суперкласу оголошень public, то перевизначуваний метод у підкласі може бути private чи protected.
•Методи екземплярів можуть бути перевизначені лише якщо вони успадковані підкласом.
•Методи, оголошені як final, неможливо знайти перевизначені.
•Статичні методи, оголошені як static, неможливо знайти перевизначені, але можуть бути повторно оголошені.
•Якщо метод не можна успадковувати, його не можна перевизначити.
•Підклас усередині того ж пакета, що і суперклас примірника, може перевизначати будь-який метод суперкласу, який не оприлюднений як private чи final.
•Підклас в іншому пакеті може перевизначати лише final методи, оголошені як public або protected.
•Перевизначуваний метод може видавати будь-які неперевірені винятки незалежно від того, чи перевизначає перевизначений метод якісь неперевірені винятки чи ні. Однак, метод, що перевизначається, не повинен генерувати перевірені винятки, які є більшими або ширшими, ніж ті, які оголошені перевизначеним методом. Перевизначений метод може генерувати вужчі або менші винятки, ніж перевизначений метод.
•Конструктори не можна перевизначити.



		~Використання ключового слова super
Викликаючи версію суперкласу перевизначеного методу, використовується ключове слово super.

	Приклад
class Animal {
   public void move() {
      System.out.println("Тварини можуть рухатися");
   }
}

class Dog extends Animal {
   public void move() {
      super.move(); // Викликає метод суперкласу
      System.out.println("Собаки можуть ходити та бігати");
   }
}

public class TestDog ​​{

   public static void main(String args[]) {
      Animal b = New Dog (); // Animal – посилання, але Dog – об'єкт
      b.move(); // Запуск методу у класі Dog
   }
}

Після запуску програми буде видано такий результат:

Тварини можуть рухатися
Собаки можуть ходити та бігати