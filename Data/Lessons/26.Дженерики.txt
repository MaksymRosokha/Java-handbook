Було б непогано, якби ми могли написати один метод сортування, який міг би сортувати елементи в масиві Integer, масиві String чи масиві будь-якого типу, що підтримує впорядкування.
Java методи узагальнення та загальні класи дозволяють програмістам вказувати з оголошенням одного методу набір пов'язаних методів або з оголошенням одного класу набір пов'язаних типів відповідно.
Java дженерики також забезпечують безпеку типу компіляції, яка дозволяє програмістам ловити неприпустимі типи під час компіляції.
Використовуючи концепцію Java Generic, ми можемо написати загальний метод для сортування масиву об'єктів, а потім викликати загальний метод із масивами Integer, Double, String і т.д., щоб відсортувати елементи масиву.


		~Загальні методи
Ви можете написати одне узагальнене оголошення методу, яке можна викликати за допомогою різних типів аргументів. Ґрунтуючись на типах аргументів, переданих на загальний метод, компілятор обробляє кожен виклик методу відповідним чином. Нижче наведено правила визначення загальних методів:
Всі оголошення узагальненого методу мають розділ параметрів типу, розділений кутовими дужками (), який передує типу методу, що повертається ( у наступному прикладі).
Розділ параметрів кожного типу містить один або кілька параметрів типу, розділених комами. Параметр типу, також відомий як змінна типу, є ідентифікатором, який вказує на загальне ім'я типу.
Параметри типу можуть використовуватися для оголошення типу, що повертається і діють як заповнювачі для типів аргументів, переданих у загальний метод, які відомі як аргументи фактичного типу.
Тіло загального методу оголошено як тіло будь-якого іншого методу. Зверніть увагу, що параметри типу можуть представляти тільки типи посилань, а не примітивні типи (наприклад, int, double і char).
	Приклад
Наступний приклад показує, як ми можемо виводити масив різного типу, використовуючи один загальний:

public class GenericMethodTest {
   // Загальний метод printArray
   public static < E > void printArray( E[] inputArray ) {
      // Відображаємо елементи масиву
      for(E element : inputArray) {
         System.out.printf("%s", element);
      }
      System.out.println();
   }

   public static void main(String args[]) {
      // Створення масивів типу Integer, Double та Character
      Integer[] intArray = { 1, 2, 3, 4, 5 };
      Double[] doubleArray = {1.1, 2.2, 3.3, 4.4};
      Character[] charArray = { 'П', 'Р', 'И', 'В', 'і', 'Т'};

      System.out.println("Масив integerArray містить:");
      printArray(intArray); // передати масив Integer

      System.out.println("\nМасив doubleArray містить:");
      printArray(doubleArray); // передати масив Double

      System.out.println("\nМасив characterArray містить:");
      printArray(charArray); // передати масив Character
   }
}
Отримаємо наступний результат:

Масив integerArray містить:
1 2 3 4 5

Масив doubleArray містить:
1.1 2.2 3.3 4.4

Масив characterArray містить:
ПРИВІТ


		~Параметри обмеженого типу
Можуть бути випадки, коли ви захочете обмежити типи типів, яким можна бути переданими типу параметра. Наприклад, метод, який працює з числами, може приймати тільки екземпляри Number або його підкласів. Для цього використовуються параметри обмеженого типу.
Щоб оголосити параметр обмеженого типу, введіть назву типу типу, за яким слідує ключове слово extends, а потім його верхня межа.
	Приклад
Наступний приклад ілюструє, як extends використовується у сенсі для позначення або «extends» (як і класах), або «implements» (як інтерфейсах). Це приклад загального методу повернення найбільшого з трьох об'єктів Comparable:

public class MaximumTest {
   // Визначаємо найбільший із трьох Comparable об'єктів
   
   public static > T maximum (T x, T y, T z) {
      T max = x; // Припустимо, що x спочатку максимальний
      
      if(y.compareTo(max) > 0) {
         max = y; // тут y поки що найбільший
      }
      
      if(z.compareTo(max) > 0) {
         max = z; // тут z найбільший зараз
      }
      return max; // Повертається максимальний об'єкт
   }
   
   public static void main(String args[]) {
      System.out.printf("Максимум з %d, %d і %d є %d\n\n",
         3, 4, 5, maximum(3, 4, 5));

      System.out.printf("Максимумом з %.1f,%.1f і %.1f є %.1f\n\n",
         6.6, 8.8, 7.7, maximum(6.6, 8.8, 7.7));

      System.out.printf("Максимум з %s, %s і %s є %s\n","груша",
         "яблуко", "апельсин", maximum ("груша", "яблуко", "апельсин"));
   }
}
Отримаємо наступний результат:

Максимум з 3, 4 і 5 є 5

Максимумом з 6.6,8.8 та 7.7 ​​є 8.8

Максимумом з груша, яблуко та апельсин є груша


		~Загальні класи
Оголошення загального класу виглядає як оголошення не загального класу, за винятком того, що за ім'ям класу слідує розділ параметрів типу.
Як і у випадку із загальними методами, розділ параметрів типу універсального класу може мати один або кілька параметрів типу, розділених комами. Ці класи відомі як параметризовані класи або типи параметризовані, оскільки вони приймають один або кілька параметрів.
	Приклад
Наступний приклад показує, як ми можемо визначити загальний клас:

public class Box {
    private T t;

    public void add(T t) {
       this.t = t;
    }

    public T get() {
       return t;
    }

    public static void main(String[] args) {
       Box integerBox = новий Box();
       Box stringBox = новий Box();
    
       integerBox.add(new Integer(10));
       stringBox.add(new String("Привіт Світ"));

       System.out.printf("Значення Integer: %d\n\n", integerBox.get());
       System.out.printf("Значення String :%s\n", stringBox.get());
    }
}
Отримаємо наступний результат:

Значення Integer :10
Значення String :Hello World