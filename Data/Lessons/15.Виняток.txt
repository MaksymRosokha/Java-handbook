Виняток у Java - є проблемою, яка виникає в ході виконання програми. У разі виникнення в Java виключення (exception), або виняткової події, має місце припинення нормальної течії програми, і програма/додаток завершуються в аварійному режимі, що не є рекомендованим, і, як наслідок, подібні випадки вимагають Java оброблення винятків.

		~Причини виникнення виключення
Існує безліч причин, які можуть призвести до виникнення винятку. Далі розглянуто низку подібних сценаріїв, у тих яких може статися виняток:

•Користувач запровадив неприпустимі дані.
•Файл, який потрібно відкрити, не знайдено.
•З'єднання з мережею втрачено у процесі передачі чи JVM вичерпала наявний обсяг пам'яті.

Деякі з цих винятків викликані помилкою користувача, інші — програмною помилкою, в деяких випадках, причиною цього може стати збій у матеріальних ресурсах.
Виходячи з наведених відомостей, ми можемо позначити три типи винятків. Знання цих типів дозволить вам надалі вирішувати проблемні ситуації, пов'язані з винятками. Нижче розглянемо список винятків Java з прикладами.

•Контрольовані винятки - контрольований виняток є вид винятку, що відбувається на стадії компіляції, їх також називають винятками періоду компіляції. Зазначені винятки не слід ігнорувати в ході компіляції, вони вимагають належного поводження з програміста.
Наприклад, якщо ви використовуєте клас FileReader у вашій програмі для зчитування даних із файлу, у разі, якщо зазначений у конструкторі файл не існує, відбувається FileNotFoundException, і компілятор нагадує програмісту обробку цього виключення.

Приклад 1
import java.io.File;
import java.io.FileReader;

public class Test {

   public static void main(String args[]) {		
      File f = new File("D://java/file.txt");
      FileReader fr = new FileReader(f); 
   }
}

При спробі компіляції зазначеної вище програми буде виведено такі винятки:

C:\>javac Test.java
Test.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown
      FileReader fr = new FileReader(f);
                      ^
1 error

Примітка . Зважаючи на те, що методи read() і close() класу FileReader викликають IOException, компілятор може повідомити вас про обробку IOException, спільно з FileNotFoundException.

•Неконтрольовані винятки — неконтрольований виняток є винятком, який відбувається під час виконання. Вони також звуться винятку на етапі виконання . Ця категорія може містити похибки програмування, такі як логічні помилки або неправильний спосіб використання API. Винятки на етапі виконання ігноруються під час компіляції.
Наприклад, якщо вами у вашій програмі було оголошено масив із 5 елементів, спроба виклику 6-го елемента масиву спричинить виникнення ArrayIndexOutOfBoundsExceptionexception.

Приклад 2
public class Test {
   
   public static void main(String args[]) {
      int array[] = {1, 2, 3};
      System.out.println(array[4]);
   }
}

При компіляції та виконанні зазначеної вище програми буде отримано такий виняток:

Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5
	at Exceptions.Test.main(Test.java:8)

•Помилки - не є винятками, проте представляють проблеми, які виникають незалежно від користувача або програміста. Помилки у вашому коді зазвичай ігноруються через те, що в окремих випадках їх обробка виявиться результативною. Наприклад, помилка з'явиться при переповненні стека. На етапі компіляції вони також ігноруються.


		~Обробка винятків - try і catch
Метод здійснює обробку виключення під час використання ключових слів try і catch .

Опис
Блок try/catch розміщується на початку та наприкінці коду, який може згенерувати виняток. Код у складі блоку try/catch є захищеним кодом, синтаксис використання try/catch виглядає так:

try {
   // Захищений код
}catch(НазваниеИсключения e1) {
   // Блок catch
}
Код, схильний до винятків, розміщується у блоці try. У разі виключення, обробка даного виключення буде здійснюватися відповідним блоком catch. За кожним блоком try повинен негайно слідувати блок catch чи блок finally.
Оператор catch включає оголошення типу виключення, яке має бути оброблено. При виникненні виключення в захищеному коді блок catch (або блоки), наступний за try, буде перевірений. У випадку, якщо тип виключення представлений в блоці catch, виняток передається в блок catch аналогічно тому, як аргумент передається в параметр методу.
	Приклад
Нижче представлений масив із заявленими двома елементами. Спроба коду отримати доступ до третього елементу масиву спричинить генерацію виключення.

import java.io.*;

public class Test {

    public static void main(String args[]) {
       try {
          int array[] = new int[2];
          System.out.println("Доступ до третього елемента:" + array[3]);
       } catch (ArrayIndexOutOfBoundsException e) {
          System.out.println("Виключення:" + e);
       }
       System.out.println("Поза блоком");
    }
}
Внаслідок цього буде отримано наступний результат:

Виняток:java.lang.ArrayIndexOutOfBoundsException: 3
Поза блоком


		~Багаторазові блоки catch
За блоком try можуть йти кілька блоків catch. Синтаксис багаторазових блоків catch виглядає так:

try {
   // Захищений код
} catch (ВинятокТип1 e1) {
   // Блок catch
} catch (ВинятокТип2 e2) {
   // Блок catch
} catch (ВинятокТип3 e3) {
   // Блок catch
}
Представлені вище оператори демонструють три блоки catch, проте після одноразового try кількість даних використовуваних блоків може бути довільним. У разі виникнення виключення у захищеному коді виняток виводиться у перший блок catch у списку. Якщо тип даних виключення, що генерується, збігається з Винятком Тип1, він перехоплюється у зазначеній області. В іншому випадку виняток переходити до іншого оператора catch. Це триває доти, доки не буде зроблено перехоплення виключення, або воно не пройде через всі оператори, в разі чого виконання поточного методу буде припинено, і виняток буде перенесено до попереднього методу стеку викликів.
	Приклад
Далі представлений сегмент коду, що демонструє використання багаторазових операторів try/catch.

try {
   file = New FileInputStream(fileName);
   x = (byte) file.read();
} catch (IOException e1) {
   e1.printStackTrace();
   return -1;
} catch (FileNotFoundException e2) // Недійсно! {
   e2.printStackTrace();
   return -1;
}


		~Перехоплення багатотипних винятків
У середовищі Java 7, Ви можете зробити обробку більш ніж одного винятку при використанні одного блоку catch, ця властивість спрощує код. Нижче представлена ​​модель реалізації:

catch (IOException|FileNotFoundException ex) {
   logger.log(ex);
   throw ex;


		~Ключові слова throws/throw
Якщо метод не може здійснити обробку контрольованого виключення, здійснюється повідомлення при використанні ключового слова throws Java. Ключове слово throws з'являється в кінці методу сигнатури.

При використанні ключового слова throw можна зробити обробку виявленого виключення або виключення, яке було тільки що перехоплено.

Слід уважно розрізняти ключові слова throw і throws Java, оскільки throws використовується для відкладеної обробки контрольованого виключення, а throw, у свою чергу, використовується для виклику заданого виключення.

Нижче наведений метод відображає, що ним генерується RemoteException:

Приклад 1
import java.rmi.RemoteException;
public class Test {

   public void deposit(double amount) throws RemoteException {
      // Реалізація методу
      throw new RemoteException();
   }
   // Залишок визначення класу
}
Метод також може повідомити про те, що їм генерується більш ніж один виняток, у разі чого винятки подаються у вигляді переліку, відокремлені один від одного грудками. Наприклад, наступний метод повідомляє про те, що їм генеруються RemoteException і InsufficientFundsException:

Приклад 2
import java.rmi.RemoteException;
public class Test {

   public void withdraw(double amount) throws RemoteException,
      InsufficientFundsException {
      // Реалізація методу
   }
   // Залишок визначення класу
}



		~Блок finally
У Java finally слід за блоком try чи блоком catch. Блок finally у коді виконується завжди незалежно від наявності винятку.

Використання блоку finally дозволяє запустити будь-який оператор, призначений для очищення, незалежно від того, що відбувається у захищеному коді.

Блок finally в Java з'являється після закінчення блоків catch, його синтаксис виглядає так:

	Синтаксис
try {
   // Захищений код
} catch (ВинятокТип1 e1) {
   // Блок catch
} catch (ВинятокТип2 e2) {
   // Блок catch
} catch (ВинятокТип3 e3) {
   // Блок catch
}finally {
   // Блок finally завжди виконується.
}
	Приклад
public class Test {

   public static void main(String args[]) {
      int array[] = new int[2];
      try {
         System.out.println("Доступ до третього елементу:" + array[3]);
      } catch (ArrayIndexOutOfBoundsException e) {
         System.out.println("Виключення:" + e);
      }finally {
         array[0] = 6;
         System.out.println("Значення першого елемента: " + array[0]);
         System.out.println("Оператор finally виконаний.");
      }
   }
}
Внаслідок цього буде отримано наступний результат:

Виняток:java.lang.ArrayIndexOutOfBoundsException: 3
Значення першого елемента: 6
Оператор finally виконаний.

Слід пам'ятати, що:
•Вираз catch не може існувати без оператора try.
•За наявності блоку try/catch, вираз finally не є обов'язковим.
•Блок try не може існувати за відсутності виразу catch чи висловлювання finally.
•Існування будь-якого коду в проміжку між блоками try, catch, finally є неможливим.


		~Конструкція try-with-resources
В нормі, при використанні різних видів ресурсів, таких як потоки, з'єднання та ін, нам належить закрити їх безпосередньо при використанні блоку. У програмі, наведеній нижче, нами проводиться зчитування даних із файлу при використанні FileReader, після чого він закривається блоком finally.

Приклад 1
import java.io.FileReader;
import java.io.File;
import java.io.IOException;

public class Test {

   public static void main(String args[]) {
      FileReader fr = null;
      try {
         File f = new File("file.txt");
         fr = новий FileReader(f);
         char[] array = new char[10];
         fr.read(array); // Читання вмісту масиву
         for(char c : array)
         System.out.print(c); // Виведення символів на екран, один за одним
      } catch (IOException e1) {
         e1.printStackTrace();
      }finally {
         try {
            fr.close();
         } catch (IOException e2) {
            e2.printStackTrace();
         }
      }
   }
}
Конструкція try-with-resources, також називається як автоматичне управління ресурсами, представляє новий механізм обробки винятків, який був представлений у 7-й версії Java, здійснюючи автоматичне закриття всіх ресурсів, що використовують у рамках блоку try catch.

Щоб скористатися даним оператором, вам потрібно розмістити задані ресурси у круглих дужках, після чого створений ресурс буде автоматично закритий після закінчення блоку. Нижче наведено синтаксис конструкції try-with-resources.

	Синтаксис
try(FileReader fr = new FileReader("Шлях до файлу")) {
   // Використання ресурсу
   } catch () {
      // тіло catch
   }
}
Програма нижче зчитує дані у файлі, використовуючи конструкцію try-with-resources.

	Приклад 2
import java.io.FileReader;
import java.io.IOException;

public class Test {

   public static void main(String args[]) {
      try(FileReader fr = новий FileReader("E://Soft/NetBeans 8.2/Projects/test/test/file.txt")) {
         char[] array = new char[10];
         fr.read(array); // Читання вмісту масиву
         for(char c : array)
         System.out.print(c); // Виведення символів на екран, один за одним
      } catch (IOException e) {
         e.printStackTrace();
      }
   }
}
При роботі з конструкцією try-with-resources слід брати до уваги такі нюанси:
•Для використання конструкції try-with-resources слід реалізувати інтерфейс AutoCloseable, після чого відповідний метод close() буде викликаний автоматично під час виконання.
•У конструкції try-with-resources можливе вказівку одного і більше класів.
•При вказівці кількох класів у блокі try конструкції try-with-resources закриття даних класів буде здійснюватися в зворотному порядку.
•За винятком внесення ресурсів у дужки, всі елементи є рівними аналогічно нормальному блоку try/catch у складі блоку try.
•Ресурси, внесені до try, конкретизуються до запуску блоку try.
•Ресурси у складі блоку try вказуються як залишкові.


		~Створення власних винятків
Ви можете створити власні винятки у середовищі Java. При записі своїх класів винятків слід брати до уваги такі аспекти:
•Усі винятки мають бути дочірніми елементами Throwable.
•Якщо ви плануєте зробити запис контрольованого виключення з автоматичним використанням за допомогою правила обробки чи оголошення, вам слід розширити клас Exception.
•Якщо ви хочете зробити запис виключення на етапі виконання, вам слід розширити клас RuntimeException.
Ви можете визначити свій клас винятків, як показано нижче:

class MyException extends Exception {
}

Вам необхідно розширити певний клас Exception з метою створення власного виключення. Ця категорія відноситься до контрольованих винятків. Наступний клас InsufficientFundsException виняткових ситуацій, що визначаються користувачем, розширює клас Exception, роблячи його контрольованим винятком. Клас винятків, подібно до всіх інших класів, містить використовувані області та методи.
	Приклад
// Назва файлу InsufficientFundsException.java
import java.io.*;

public class InsufficientFundsException extends Exception {
   private double amount;
   
   public InsufficientFundsException(double amount) {
      this.amount = amount;
   }
   
   public double getAmount() {
      return amount;
   }
}
З метою демонстрації наших винятків, визначених користувачем, наступний клас Checking містить метод withdraw(), що генерує InsufficientFundsException.

// Назва файлу Checking.java
import java.io.*;

public class Checking {
   private int number;
   private double balance;
   
   public Checking(int number) {
      this.number = number;
   }
   
   public void deposit(double amount) {
      balance + = amount;
   }
   
   public void withdraw(double amount) throws InsufficientFundsException {
      if(amount <= balance) {
         balance -= amount;
      }else {
         double needs = amount - balance;
         throw new InsufficientFundsException(needs);
      }
   }
   
   public double getBalance() {
      return balance;
   }
   
   public int getNumber() {
      return number;
   }
}

Наступна програма Bank демонструє виклик методів deposit() та withdraw() класу Checking.

// Назва файлу Bank.java
public class Bank {

   public static void main(String [] args) {
      Checking c = New Checking (101);
      System.out.println("Депозит $300...");
      c.deposit(300.00);
      
      try {
         System.out.println("\nЗняття $100...");
         c.withdraw(100.00);
         System.out.println("\nЗняття $400...");
         c.withdraw(400.00);
      } catch (InsufficientFundsException e) {
         System.out.println("Вибачте, але у Вас $" + e.getAmount());
         e.printStackTrace();
      }
   }
}

Скомпілюйте всі три вище зазначені файли та здійсніть запуск Bank. Внаслідок цього буде отримано наступний результат:

$300 Депозит...

Зняття $100...

Зняття $400...
Вибачте, але у Вас $200.0
НедостатніFundsException
         at Checking.withdraw(Checking.java:25)
         at Bank.main(Bank.java:13)


		~Загальні винятки
У Java можна виділити дві категорії винятків та помилок.
•Винятки JVM - дана група представлена ​​винятками / помилками, які викликаються безпосередньо та логічно з боку JVM. Приклади: NullPointerException, ArrayIndexOutOfBoundsException, ClassCastException.
•Програмні винятки - ці винятки викликаються безпосередньо додатком або програмістами API. Приклади: IlegallegalArgumentException, IlegallegalException.