Java пакети (package) використовуються для запобігання конфліктам з назвами, для контролю доступу, для полегшення пошуку/знаходження та використання класів, інтерфейсів, перерахувань і анотацій і т.д.

Пакети можна визначити як угруповання пов'язаних типів (класи, інтерфейси, перерахування та анотації), що надає захист доступу та керування простором імен.

Деякі з існуючих пакетів у Java:

•java.lang – пов'язує фундаментальні класи.
•java.io – класи для введення та вивідні функції пов'язані у цьому пакеті.

Програмісти можуть визначити їх пакети для зв'язування груп класів/інтерфейсів і т.д. Угруповання пов'язаних класів, реалізованих вами, є добрим практичним рішенням, т.к. програміст зможе легко визначити, що класи, інтерфейси, перерахування та анотації пов'язані.

Оскільки пакет створює новий простір імен, він не матиме жодних конфліктів з іменами в інших пактах. Використовуючи пакети, легше надати керування доступом та легше знайти пов'язані класи.

	~Створення пакету
Як створити пакет Java? Під час створення пакета ви повинні вибрати йому ім'я та включити оператор package разом із цим ім'ям поверх кожного вихідного файлу, який містить класи, інтерфейси, перерахування та типи анотацій, які ви хочете включити до пакета.

Оператор package має бути першим рядком у вихідному файлі. Може бути лише один запит package у кожному вихідному файлі, і він застосовується до всіх типів у цьому файлі.

Якщо оператор package не використаний, тоді класи, інтерфейси, перерахування та типи анотацій будуть розміщені в поточному пакеті за замовчуванням.

Щоб скомпілювати програми на Java з операторами package, вам потрібно використовувати опцію –d, як показано нижче.

javac -d Destination_folder file_name.java

Потім у вказаному місці призначення створюється папка із вказаним ім'ям пакета, а файли скомпілованих класів будуть поміщені до цієї папки.

	Приклад 1
Давайте поглянемо на приклад, який створює пакет під назвою animals . Корисно використовувати імена пакетів з маленької літери, щоб уникнути конфліктів із іменами класів та інтерфейсів.

В следующем примере пакета содержится интерфейс с названием animals.

/* File name : Animal.java */
package animals;

interface Animal {
   public void eat();
   public void travel();
}

Тепер давайте реалізуємо вищенаведений інтерфейс у цьому ж пакеті animals:

package animals;
/* File name : MammalInt.java */

public class MammalInt implements Animal {

   public void eat() {
      System.out.println("Ссавник їсть");
   }

   public void travel() {
      System.out.println("Ссавник подорожує");
   }

   public int noOfLegs() {
      return 0;
   }

   public static void main(String args[]) {
      MammalInt m = New MammalInt();
      m.eat();
      m.travel();
   }
}

А зараз скомпілюємо java-файли, як показано нижче:

$ javac -d. Animal.java
$ javac -d. MammalInt.java

Тепер пакет/папка з іменем animals буде створена в поточній директорії, і файли класів будуть поміщені до неї.

Ви можете запустити файл класу всередині пакета та отримати результат, вказаний нижче.

Mammal eats
Mammal travels

Ключове слово import

Якщо клас хоче використовувати інший клас у тому пакеті, то не потрібно використовувати ім'я пакета. Класи в одному пакеті можуть знайти один одного без спеціального синтаксису.

	Приклад 2
Отже, клас під назвою Boss доданий до пакету payroll, який вже містить Employee. Boss може звернутися до класу Employee без використання префікса payroll, як показано у наступному класі Boss.

package payroll;
public class Boss {
   public void payEmployee(Employee e) {
      e.mailCheck();
   }
}

Що станеться, якщо клас Employee не буде включений у пакет payroll? Тоді клас Boss повинен використовувати одну з наступних технік для звернення до класу в іншому пакеті:

•Можна використати повноцінне ім'я класу. Наприклад:
payroll.Employee

•Імпорт пакету. Java пакет може бути імпортований за допомогою ключового слова import і wild card. (*). Наприклад:
import payroll.*;

•Сам клас можна імпортувати за допомогою ключового import. Погляньмо:
import payroll.Employee;

Примітка: Файл класу може містити будь-яку кількість імпортерів (import). Оператори імпорту (import) мають з'являтися після оператора пакета (package) і до оголошення класу.

		~Структура директорії пакетів
Відбуваються два явища, коли клас поміщений у пакет:
•Ім'я пакета Java стає частиною імені класу, як ми тільки що з'ясували в минулій секції.
•Ім'я пакета має відповідати структурі директорії, де знаходиться відповідний байт-код.

Є легкий спосіб роботи з вашими файлами в Java:

Помістіть вихідний код для класу, інтерфейсу, перерахування або типу анотації у текстовий файл, ім'я якого є простим ім'ям типу з розширенням .java.

Наприклад:

// File Name : Car.java
package vehicle;

public class Car {
   // Class implementation.
}

Тепер помістіть вихідний файл у директорію, ім'я якої відображає ім'я пакета, до якого належить клас:

....\vehicle\Car.java

Повноцінне ім'я класу та шляху виглядатиме так:

•Ім'я класу – vehicle.Car
•Шлях до файлу – vehicle\Car.java (у Windows)

Загалом компанія використовує своє зворотне доменне ім'я в Інтернеті для своїх іменувань пакетів в Java.

Наприклад: доменне ім'я компанії називається apple.com, тоді всі імена пакетів будуть починатися з com.apple. Кожен компонент імені пакета відповідає піддиректорії.

Наприклад: компанія має пакет com.apple.computers, у якому міститься вихідний файл Dell.java, тоді він міститься в серії піддиректорій, як зазначено тут:

....\com\apple\computers\Dell.java

Компілятор створює під час компіляції інший файл виводу для кожного класу, інтерфейсу та переліку, визначених у ньому. Звичайне ім'я виводу складається з імені типу і розширення .class.

	Наприклад:

// File Name: Dell.java
package com.apple.computers;

public class Dell {
}

class Ups {
}

Тепер скомпілюйте це за допомогою опції –d:

$javac -d. Dell.java

Файли скомпілюються таким чином:

.\com\apple\computers\Dell.class
.\com\apple\computers\Ups.class

Ви можете імпортувати всі класи та інтерфейси, визначені в \com\apple\computers\ ось так:

import com.apple.computers.*;

Як і вихідні файли .java, скомпіловані файли .class повинні бути в серії директорій, які відображають ім'я пакета. Однак шлях до файлів .class не повинен бути таким самим, як шлях до вихідних файлів .java. Ви можете розділити директорії для класів та джерел ось так:

\sources\com\apple\computers\Dell.java

\classes\com\apple\computers\Dell.class

Роблячи так, можна надати доступ до директорії класів іншим програмістам, не розкриваючи ваші джерела. Вам також потрібно розподілити файли класів та джерел таким чином, щоб компілятор та Java Virtual Machine (JVM) могли знайти всі типи, які використовує ваша програма.

Повний шлях до директорії класів \classes називається шлях класу та встановлюється із системною змінною CLASSPATH. І компілятор, і JVM створюють шлях до файлів .class, додаючи ім'я пакета до шляху класу.

Допустимо, \classes - це шлях класу, а ім'я пакета com.apple.computers, тоді компілятор і JVM будуть шукати файли .class в \classes\com\apple\computers.

Шлях класу може містити кілька шляхів. Багато шляхів повинні бути відокремлені крапкою з комою (Windows) або двокрапкою (Unix). За промовчанням компілятор і JVM шукають поточну директорію та JAR-файл, що містить класи платформи Java, щоб ці директорії були автоматично включені в шлях класу.


		~Встановити системну змінну CLASSPATH
Щоб відобразити поточну змінну CLASSPATH, використовуйте такі команди у Windows і UNIX (Bourne shell):
•Для Windows - C:\> set CLASSPATH
•Для UNIX - % echo $ CLASSPATH

Щоб видалити вміст змінної CLASSPATH, використовуйте:
•Для Windows - C:\> set CLASSPATH =
•Для UNIX - % unset CLASSPATH; export CLASSPATH

Щоб встановити системну змінну CLASSPATH:
•Для Windows - установіть CLASSPATH = C:\users\jack\java\classes
•Для UNIX - % CLASSPATH = /home/jack/java/classes; експортувати CLASSPATH