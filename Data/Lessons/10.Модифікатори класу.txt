Java надає ряд модифікаторів не для доступу, а для багатьох інших функціональних можливостей:
•модифікатор static застосовується для створення методів та змінних класу;
•модифікатор final використовується для завершення реалізації класів, методів та змінних;
•модифікатор abstract необхідний створення абстрактних класів і методів;
•модифікатори synchronized і volatile використовуються в Java для потоків.


		~Модифікатор static
Модифікатор static – застосовується для створення методів та змінних класу.

		Змінні static
Ключове слово static використовується для створення змінних, які будуть існувати незалежно від екземплярів, створених для класу. Тільки одна копія змінної static Java існує незалежно від кількості екземплярів класу.
Статичні змінні також відомі як змінні класу. У Java локальні змінні неможливо знайти оголошені статичними (static).

		Методи static
Ключове слово static використовується для створення методів, які існуватимуть незалежно від будь-яких екземплярів, створених для класу.
У Java статичні методи або методи static не використовують будь-які змінні екземпляри будь-якого об'єкта класу, вони визначені. Методи static приймають усі дані з параметрів і щось із цих параметрів обчислюється без посилання змінні.
Змінні та методи класу можуть бути доступні з використанням імені класу, за яким слідує точка та ім'я змінної або методу.
	Приклад
Модифікатор static Java використовується для створення методів класів і змінних, як показано в наступному прикладі:

public class InstanceCounter {

   private static int numInstances = 0;

   protected static int getCount() {
      return numInstances;
   }

   private static void addInstance() {
      numInstances++;
   }

   InstanceCounter() {
      InstanceCounter.addInstance(); 
   }

   public static void main(String[] arguments) {
      System.out.println("Начиная с " +
      InstanceCounter.getCount() + " экземпляра");
      for (int i = 0; i < 500; ++i){
         new InstanceCounter();
	  }
      System.out.println("Создано " +
      InstanceCounter.getCount() + " экземпляров");
   }
}
Буде отримано наступний результат:

Починаючи з 0 екземпляра
Створено 500 екземплярів



		~Модифікатор final
Модифікатор final - використовується для завершення реалізації класів, методів та змінних.

		Змінні final
Змінна final може бути ініціалізована лише один раз. Посилальна змінна, оголошена як final, ніколи не може бути призначена для позначення іншого об'єкта.
Однак, дані всередині об'єкта можуть бути змінені. Таким чином, стан об'єкта може бути змінено, але не посилання.
Зі змінними в Java модифікатор final часто використовується зі static, щоб зробити константою змінну класу.
	Приклад
public class Test{
  final int value = 10;
  // Нижче наведено приклади оголошення констант:
  public static final int BOXWIDTH = 6;
  static final String TITLE = "Менеджер";
  
  public void changeValue(){
     value = 12; //буде отримана помилка
  }
}
		Методи final
Метод final може бути перевизначений будь-яким підкласом. Як згадувалося раніше, Java модифікатор final запобігає методу від змін у підкласі.
Головним наміром зробити метод final буде те, що зміст методу не повинен бути змінений стороні.
	Приклад
Оголошення методу, що використовує модифікатор final оголошення класу, показано в наступному прикладі:

public class Test{
    public final void changeName(){
       // тело метода
    }
}
		Клас final
Основна мета в Java використання класу оголошеного як final полягає в запобіганні класу бути підкласом. Якщо клас позначається як final, то жоден клас не може успадковувати будь-яку функцію класу final.
	Приклад
public final class Test {
   // тіло класа
}



		~Модифікатор abstract
Модифікатор abstract – використовується для створення абстрактних класів та методів.

		Клас abstract
Клас abstract не може створити екземпляр. Якщо клас оголошений як abstract, єдина мета йому бути розширеним.
Клас може бути одночасно abstract і final, оскільки клас final може бути розширеним. Якщо клас містить абстрактні методи, він повинен бути оголошений як abstract. В іншому випадку буде згенеровано помилку компіляції.
Клас abstract може містити як абстрактні методи, так і звичайні.
	Приклад
abstract class Caravan{
   private double price;
   private String model;
   private String year;
   public abstract void goFast(); //абстрактний метод
   public abstract void changeColor();
}

		Метод abstract
Метод abstract є методом, оголошеним із будь-якою реалізацією. Тіло методу (реалізація) забезпечується підкласом. Методи abstract ніколи не можуть бути final або strict.
Будь-який клас, який розширює абстрактний клас, повинен реалізувати всі абстрактні методи суперкласу, якщо підклас не є абстрактним класом.
Якщо клас Java містить один або кілька абстрактних методів, то клас повинен бути оголошений як abstract. Абстрактний клас ні містити абстрактні методы.
Абстрактний метод закінчується крапкою з комою. приклад: public abstract sample();
	Приклад
public abstract class SuperClass{
    abstract void m(); //абстрактний метод
}

class SubClass extends SuperClass{
     // реализует абстрактний метод
      void m(){
	  .........
      }
}



		~Модифікатор synchronized
Модифікатор synchronized — використовуються Java для потоків.
Ключове слово synchronized використовується для вказівки того, що метод може бути доступний лише одним потоком одночасно. У Java модифікатор synchronized може бути застосований з будь-яким із чотирьох модифікаторів рівня доступу.
	Приклад
public synchronized void showDetails(){
.......
}



		~Модифікатор transient
Змінна екземпляра, зазначена як transient, вказує віртуальній машині Java (JVM), щоб пропустити певну змінну при серіалізації об'єкта, що містить її.
Цей модифікатор включений до оператора, що створює змінну, попереднього класу або типу даних змінної.
	Приклад
public transient int limit = 55;   // не будет сохраняться
public int b; // будет сохраняться
Модифікатор volatile
Модифікатор volatile - використовуються в Java для потоків.
У Java модифікатор volatile використовується, щоб дозволити знати JVM, що потік доступу до змінної завжди повинен об'єднувати власну копію змінної з головною копією в пам'яті.
Доступ до змінної volatile синхронізує всі скопійовані кешовані змінні в оперативній пам'яті. Volatile може бути застосований тільки до змінних примірників, які мають тип об'єкта або private. Посилання на об'єкт volatile може бути null.
	Приклад
public class MyRunnable implements Runnable{
    private volatile boolean active;
 
    public void run(){
        active = true;
        while (active){ // линия 1
            // здесь какой-нибудь код
        }
    }
    
    public void stop(){
        active = false; // линия 2
    }
}
Як правило, run() викликається в одному потоці (вперше починаєте використовувати Runnable Java), а stop() викликається з іншого потоку. Якщо в лінії 1 використовується кешоване значення active, цикл не може зупинитися, поки Ви не встановите active false в лінії 2.