Інтерфейс - це тип посилання в Java. Він схожий із класом. Це сукупність абстрактних методів. Клас реалізує інтерфейс, таким чином наслідуючи абстрактні методи інтерфейсу.

Разом з абстрактними методами інтерфейс Java може містити константи, звичайні методи, статичні методи і вкладені типи. Тіла методів існують лише для звичайних методів та статичних методів.

Далі розберемо навіщо потрібні інтерфейси в Java і для чого використовуються різницю абстрактного класу та інтерфейсу.

Написання інтерфейсу подібне до написання класу. Але клас визначає атрибути та поведінки об'єкта. Інтерфейс містить поведінки, які клас реалізує.

Якщо клас, що реалізує інтерфейс, не є абстрактним, всі методи інтерфейсу мають бути визначені у класі.


		~Чим схожі клас та інтерфейс?
Інтерфейс схожий з класом так:

•Інтерфейс може містити будь-яку кількість методів.
•Інтерфейс записаний у файлі з розширенням .java і ім'я інтерфейсу збігається з ім'ям файлу.
•Байт-код інтерфейсу знаходиться у .class файлі.
•Інтерфейси з'являються в пакетах, і їхній відповідний файл байт-коду повинен бути в структурі каталогів, яка збігається з ім'ям пакета.


		~Чим відрізняється клас від інтерфейсу?
Однак, інтерфейс все ж таки відрізняється від класу. Відмінність інтерфейсу від класу Java:
•Ви не можете створити екземпляр інтерфейсу.
•В інтерфейсі не містяться конструктори.
•Усі методи в інтерфейсі абстрактні.
•Інтерфейс не може містити поля екземплярів. Поля, які можуть виникнути в інтерфейсі, мають бути оголошені і статичними, і final.
•Інтерфейс не розширюється класом, він реалізується класом.
•Інтерфейс може розширити багато інтерфейсів.


		~Оголошення інтерфейсів
Ключове слово interface використовується для оголошення інтерфейсу. Ось приклад того, як можна створити інтерфейс:

	Приклад 1
/* File name : NameOfInterface.java */
import java.lang.*;
// Будь-яка кількість запитів імпорту

public interface NameOfInterface { // створення інтерфейсу
   // Будь-яка кількість полів final і static
   // Будь-яка кількість оголошень абстрактних методів
}

Інтерфейси мають такі характеристики:
•Анотація інтерфейс побічно. Вам не потрібно використовувати ключове слово abstract під час оголошення інтерфейсу.
•Кожен метод в інтерфейсі опосредковано абстрактним, тому ключове слово abstract не потрібне.
•Методи в інтерфейсі опосредковано публічні.

	Приклад 2
/* File name : Animal.java */
interface Animal {
   public void eat();
   public void travel();
}


		~Реалізація інтерфейсу
Коли клас реалізує інтерфейс, ви можете уявити, що клас ніби підписує контракт з інтерфейсом, погоджуючись зробити конкретні його поведінки. Якщо клас не виконує всі поведінки інтерфейсу, клас повинен оголосити собі абстрактним.

Клас використовує ключове слово implements для реалізації інтерфейсу. Ключове слово implements з'являється при оголошенні класу його розширеної частини.
	Приклад
/* File name : MammalInt.java */
public class MammalInt implements Animal {

   public void eat() {
      System.out.println("Ссавник їсть");
   }

   public void travel() {
      System.out.println("Ссавник подорожує");
   }

   public int noOfLegs() {
      return 0;
   }

   public static void main(String args[]) {
      MammalInt m = New MammalInt();
      m.eat();
      m.travel();
   }
}
Отримаємо таке:

Ссавця їсть
Ссавець подорожує


При перевизначенні методів в інтерфейсі, слід дотримуватися деяких правил:

•Перевірені винятки не повинні бути оголошені методами реалізації, відмінними від тих, що були оголошені методом інтерфейсу або підкласами тих, які були оголошені методом інтерфейсу.
•Підпис методу інтерфейсу того ж типу або підтипу повернення повинен підтримуватися (зберігатися) при перевизначенні методів.
•Сам клас реалізації може бути абстрактним, а якщо так, то методи інтерфейсу не повинні бути реалізовані.

При реалізації інтерфейсів є деякі правила:

•Клас може реалізувати більше одного інтерфейсу за один раз.
•Клас може розширити лише один клас, але реалізувати безліч інтерфейсів.
•Інтерфейс може розширити інший інтерфейс так само, як клас розширює інший клас.



		~Розширення інтерфейсів
Інтерфейс може розширювати інший інтерфейс так само, як інший клас. Ключове слово extends використовується для розширення інтерфейсу, а дочірній інтерфейс успадковує методи батьківського інтерфейсу.

Наведений інтерфейс Sports розширений інтерфейсами Hockey та Football.
	Приклад
// Filename: Sports.java
public interface Sports {
   public void setHomeTeam(String name);
   public void setVisitingTeam(String name);
}

// Filename: Football.java
public interface Football extends Sports {
   public void homeTeamScored(int points);
   public void visitingTeamScored(int points);
   public void endOfQuarter(int quarter);
}

// Filename: Hockey.java
public interface Hockey extends Sports {
   public void homeGoalScored();
   public void visitingGoalScored();
   public void endOfPeriod(int period);
   public void overtimePeriod(int ot);
}

Інтерфейс Hockey має чотири методи, але він успадковує два з Sports; таким чином, клас, який реалізує Hockey, має реалізувати всі шість методів. Подібно до цього, клас, який реалізує Football, повинен визначити три методи з Football і два методи зі Sports.

		~Розширення безлічі інтерфейсів
Клас Java може розширити лише один батьківський клас. Множинне успадкування неможливе. Однак інтерфейси не класи, і інтерфейс може розширити більш ніж один батьківський інтерфейс.

Ключове слово extends використовується лише раз, а батьківські інтерфейси оголошуються через комусь.

Наприклад, якщо інтерфейс Hockey розширив і Sports, і Event, оголошення виглядало б так:

public interface Hockey extends Sports, Event

		~Інтерфейси тегів
Найширше використання розширення інтерфейсів відбувається тоді, коли батьківський інтерфейс не містить будь-яких методів. Наприклад, інтерфейс MouseListener у пакеті java.awt.event розширив java.util.EventListener, який визначається так:

package java.util;
public interface EventListener
{}

Інтерфейс без методів у ньому називається інтерфейсом тегів. Є дві прості дизайнерські цілі для інтерфейсів тегів:

Створює спільного батька - як у випадку з інтерфейсом EventListener, який розширюється безліччю інших Java API, ви можете використовувати інтерфейс тегів, щоб створити спільного батька серед групи інтерфейсів. Наприклад, коли інтерфейс розширює EventListener, то JVM знає, що цей інтерфейс використовуватиметься у сценарії делегування подій.

Додає тип даних до класу – ця ситуація є джерелом терміну тегування. Клас, який реалізує інтерфейс тегів, повинен визначати будь-які методи (т.к. інтерфейс немає таких), але клас стає типом інтерфейсу через поліморфізм.