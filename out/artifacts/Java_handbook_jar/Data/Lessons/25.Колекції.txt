Аж до Java 2, Java надавала спеціальні класи, такі як Dictionary, Vector, Stack, і Properties для зберігання та управління групами об'єктів. Хоча ці класи були корисними, їм не вистачало центральної тематики, що об'єднує. Саме тому те, як ви використовували Vector, відрізняється від того, як ви використовували Properties.

Структура колекцій у Java була створена для того, щоб задовольняти такі цілі, як:
•Фреймворк має бути високопродуктивним. Реалізації фундаментальних колекцій (динамічні масиви, пов'язані списки, дерева та хеш-таблиці) мають бути високоефективними.
•Фреймворк повинен дозволяти різним типам колекцій працювати аналогічно і з високим ступенем сумісності.
•Фреймворк повинен вміти розширюватись та/або легко адаптувати колекцію

З цією метою вся структура колекцій розроблена довкола набору стандартних інтерфейсів. Декілька стандартних реалізацій типу LinkedList, HashSet, і TreeSet з цих інтерфейсів надаються таким чином, що ви можете їх використовувати як є або можете реалізувати свою власну колекцію на ваш вибір.

Фреймворк колекцій – це об'єднана архітектура для представлення та керування колекціями. Усі структури колекцій містять у собі таке:
•Інтерфейси – це абстрактні типи даних, які представляють колекції. Інтерфейси дозволяють керувати колекціями незалежно від деталей їхнього представлення. В объектно-ориентированных мовами інтерфейси зазвичай формують ієрархію.
•Реалізації, тобто. Класи – це конкретні продажі інтерфейсів колекцій. По суті вони є структурними даними, які можна багаторазово використовувати.
•Алгоритми – це методи, які виконують корисні обчислення з об'єктами, які реалізують інтерфейси колекцій, наприклад, пошук і сортування. Алгоритми вважаються поліморфними, тобто один і той же метод може бути використаний у багатьох різних реалізацій відповідного інтерфейсу колекцій.
Крім колекцій, фреймворк визначає деякі інтерфейси та класи карт. Карти зберігають пари ключ/значення. Хоча карти не є колекціями у звичайному розумінні, але вони повністю інтегровані з колекціями.


		~Інтерфейси колекцій
Структура колекцій визначає деякі інтерфейси Java. Цей розділ коротко описує кожен із них.

№	Інтерфейс та опис
1	Інтерфейс Collection
	Дозволяє працювати з групами об'єктів; знаходиться на вершині колекції ієрархії.
2	Інтерфейс List
	Розширює Collection та екземпляр List зберігає впорядкований набір елементів.
3	Інтерфейс Set
	Розширює Collection для обробки наборів, які повинні містити унікальні елементи.
4	SortedSet
	Розширює Set для обробки відсортованих наборів.
5	Map
	Прив'язує унікальні ключі до значень
6	Map.Entry
	Описує елемент (пара ключ/значення) у карті. Це внутрішній клас Map.
7	SortedMap
	Розширює Map так, щоб ключі були розташовані в порядку зростання.
8	Enumeration
Застарілий інтерфейс, що визначає методи, яким ви можете перерахувати (одержувати по одному за раз) елементи в колекції об'єктів. Цей застарілий інтерфейс було замінено на Iterator


		~Класи колекцій
Java надає набір стандартних класів колекції, які реалізують інтерфейс Collection. Деякі з класів надають повні реалізації, які можуть бути використані як є, інші є абстрактним класом, надаючи скелетні реалізації, які використовуються як початкові точки для створення конкретних колекцій.

Стандартні класи колекцій Java наведені в наступній таблиці:

№	Клас та опис
1	AbstractCollection
	Реалізує більшу частину інтерфейсу Collection
2	AbstractList
	Розширює AbstractCollection та реалізує більшу частину інтерфейсу List
3	AbstractSequentialList
	Розширює AbstractList для використання колекцією, яка використовує послідовний, а не довільний доступ до своїх елементів.
4	LinkedList
	Реалізує пов'язаний список, розширюючи AbstractSequentialList.
5	ArrayList
	Реалізує динамічний масив, розширюючи AbstractList
6	AbstractSet
	Розширює AbstractCollection та реалізує більшу частину інтерфейсу Set.
7	HashSet
	Розширює AbstractSet для використання у хеш-таблиці
8	LinkedHashSet
	Розширює HashSet, щоб дозволити ітерації порядку вставки.
9	TreeSet
	Реалізує набір, що зберігається у дереві. Розширює AbstractSet.
10	AbstractMap
	Реалізує більшість інтерфейсу Map.
11	HashMap
	Розширює AbstractMap для використання хеш-таблиці
12	TreeMap
	Розширює AbstractMap для дерева.
13	WeakHashMap
	Розширює AbstractMap для використання хеш-таблиці зі слабкими ключами.
14	LinkedHashMap
	Розширює HashMap, щоб дозволити ітерації порядку вставки.
15	IdentityHashMap
	Розширює AbstractMap та використовує рівність посилань при порівнянні документів.

Класи AbstractCollection, AbstractSet, AbstractList, AbstractSequentialList та AbstractMap надають скелетні реалізації інтерфейсів основної колекції Java, щоб звести до мінімуму зусилля, необхідні для їх реалізації.

Наступні застарілі класи, визначені java.util, обговорювалися у попередньому розділі:

№	Клас та опис
1	Vector
	Реалізує динамічний масив. Схожий на ArrayList, але з деякими відмінностями.
2	Stack
	Stack - це підклас Vector, який реалізує стандартний стек "останнім прийшов - першим пішов".
3	Dictionary
	Dictionary – це абстрактний клас, який є сховищем ключів/значень і працює так само, як і Map.
4	Hashtable
	Hashtable був частиною оригінального java.util та є конкретною реалізацією Dictionary.
5	Properties
	Properties – це підклас Hashtable. Він використовується для зберігання списків значень, у яких ключ є рядком, і значення також є рядком.
6	BitSet
	Клас BitSet створює особливий тип масиву, який містить значення біт. Цей масив може збільшуватися за потреби.


		~Алгоритми Collection
Структура колекцій визначає кілька алгоритмів, які можуть застосовуватися до колекцій та карт. Ці алгоритми визначаються як статичні методи у класі Collections.

Деякі з методів можуть генерувати ClassCastException, яке виникає при спробі порівняти несумісні типи або UnsupportedOperationException, яке виникає, коли робиться спроба змінити колекцію, що не модифікується.

Колекції визначають три статичні змінні: EMPTY_SET, EMPTY_LIST та EMPTY_MAP. Усі незмінні.

№	Алгоритм та опис
1	Алгоритми Collection
	Ось список усіх реалізацій алгоритму.


		~Як використовувати ітератор колекції Java?
Ви часто будете хотіти циклічно переміщатися елементами в колекції. Наприклад, ви захочете відобразити кожен елемент.

Найлегший спосіб це зробити – використовувати ітератор, який є об'єктом, що реалізує інтерфейс Iterator чи ListIterator.

Iterator дозволяє переміщатися по колекції, отримувати або видаляти елементи. ListIterator розширює Iterator, щоб забезпечити двонаправлений обхід списку та модифікацію елементів.

№	Метод Iterator та опис
1	Використання Iterator в Java
	Ось список всіх методів із прикладами, що надаються інтерфейсами Iterator та ListIterator.
		

		~Як використовувати компаратор?
І TreeSet, і TreeMap зберігають елементи у відсортованому порядку. Проте саме компаратор визначає, що таке відсортований порядок.

Цей інтерфейс дозволяє нам сортувати цю колекцію будь-якою кількістю різних способів. Також цей інтерфейс можна використовувати для сортування будь-яких екземплярів будь-якого класу (навіть класів, які ми не можемо змінити).

№	Метод Comparator та опис
1	Використання Comparator в Java
	Ось список усіх методів з прикладами, що надаються інтерфейсом Comparator.

Підсумок
Структура колекцій Java дає програмісту доступ до попередньо запакованих структур даних, а також до алгоритмів для їх управління.

Колекція – це об'єкт, який може містити посилання інші об'єкти. Інтерфейси колекції оголошують операції, які можуть виконуватись для кожного типу колекції.

Класи та інтерфейси структури колекцій знаходяться у java.util.



		~Інтерфейс Collection
Інтерфейс Collection - це основа, на якій побудовано структуру колекцій Java. Він оголошує основні методи, які матимуть усі колекції. Ці методи наведено у наступній таблиці.

Оскільки всі колекції реалізують Collection, знайомство з його методами необхідне розуміння фреймворку. Деякі з цих методів можуть викликати виключення UnsupportedOperationException.

	Методи
№	Метод та опис
1	boolean add(Object obj)
	Додає obj до колекції, що викликає. Повертає true, якщо об'єкт було додано до колекції. Повертає false, якщо obj вже є членом колекції, або якщо колекція не дозволяє мати дублікати.
2	boolean addAll(Collection c)
	Додає всі елементи c у колекцію, що викликає. Повертає true, якщо операція пройшла успішно (тобто, елементи були додані). А якщо ні, то повертає false.
3	void clear( )
	Видаляє всі елементи з колекції, що викликає.
4	boolean contains(Object obj)
	Повертає true, якщо obj є елементом колекції, що викликає. А якщо ні, то повертає false.
5	boolean containsAll(Collection c)
	Повертає true, якщо колекція, що викликає, містить всі елементи c. А якщо ні, то повертає false.
6	boolean equals(Object obj)
	Повертає true, якщо колекція, що викликає, and obj are equal. А якщо ні, то повертає false.
7	int hashCode( )
	Повертає хеш-код для колекції, що викликає.
8	boolean isEmpty( )
	Повертає true, якщо колекція порожня. А якщо ні, то повертає false.
9	Iterator iterator( )
	Повертає ітератор для колекції, що викликає.
10	boolean remove(Object obj)
	Видаляє один екземпляр obj із колекції, що викликає. Повертає true, якщо елемент видалено. А якщо ні, то повертає false.
11	boolean removeAll(Collection c)
	Видаляє всі елементи c з колекції, що викликає. Повертає true, якщо колекція змінилася (тобто, елементи були видалені). А якщо ні, то повертає false.
12	boolean retainAll(Collection c
	Видаляє всі елементи з колекції, що викликає, крім тих, що містяться в c. Повертає true, якщо колекція змінилася (тобто елементи були видалені. В іншому випадку повертає false).
13	int size(
	Повертає кількість елементів, що зберігаються в колекції, що викликає.
14	Object[ ] toArray( )
	Повертає масив, який містить всі елементи, що зберігаються в колекції, що викликає. Елементи масиву є копіями елементів колекції.
15	Object[ ] toArray(Object array[ ]
	Повертає масив, що містить ті елементи колекції, тип яких відповідає масиву.
	Приклад
Нижче наведено приклад, який пояснює кілька методів різних реалізацій класів з вищезазначених методів колекцій:
import java.util.*;

public class CollectionsDemo {

   public static void main(String[] args) {

      // ArrayList

      List a1 = новий ArrayList();

      a1.add("Зоря");

      a1.add("Марк");

      a1.add("Айан");

      System.out.println("ArrayList Елементи");

      System.out.print("\t" + a1);

      // LinkedList

      List l1 = New LinkedList();

      l1.add("Зоря");

      l1.add("Марк");

      l1.add("Айан");

      System.out.println();

      System.out.println("LinkedList Елементи");

      System.out.print("\t" + l1);

      // HashSet

      Set s1 = новий HashSet();

      s1.add("Зоря");

      s1.add("Марк");

      s1.add("Айан");

      System.out.println();

      System.out.println("Set Елементи");

      System.out.print("\t" + s1);

      // HashMap

      Map m1 = New HashMap();

      m1.put("Зоря", "8");

      m1.put("Марк", "31");

      m1.put("Айан", "12");

      m1.put("Дейзі", "14");

      System.out.println();

      System.out.println(" Map Елементи");

      System.out.print("\t" + m1);

   }

}
Отримаємо наступний результат:

ArrayList Елементи

[Зоря, Марк, Айан]

LinkedList Елементи

[Зоря, Марк, Айан]

Set Елементи

[Айан, Зоря, Марк]

Map Елементи

{Дейзі = 14, Аян = 12, Зоря = 8, Марк = 31}



~Інтерфейс List
Інтерфейс List Java розширює Collection і оголошує поведінку колекції, яка зберігає послідовність елементів.
•Елементи можуть бути вставлені або доступні за їхньою позицією у списку, використовуючи індекс на основі нуля.
•Список може містити елементи, що повторюються.
•На додаток до методів, визначених у Collection, List визначає деякі зі своїх, які наведені у наступній таблиці.
•Деякі методи List будуть генерувати UnsupportedOperationException, якщо колекція не може бути змінена, і ClassCastException генерується, коли один об'єкт несумісний з іншим.

	Методи
№ Метод та опис
1 void add(int index, Object obj)
	Вставляє obj в список, що викликає, по індексу, переданому в index. Будь-які елементи, що раніше існували, що знаходяться в межах або за межами точки вставки, зрушуються вгору. Таким чином елементи не перезаписуються.
2 boolean addAll(int index, Collection c)
	Вставляє всі елементи c в список, що викликає, по індексу, переданому в index. Будь-які елементи, що раніше існували, що знаходяться в межах або за межами точки вставки, зрушуються вгору. Таким чином елементи не перезаписуються. Повертає true, якщо список, що викликає, змінюється, в іншому випадку повертає false.
3 Object get(int index)
	Повертає об'єкт, що зберігається у зазначеному індексі в колекції, що викликає.
4 int indexOf(Object obj)
	Повертає індекс першого екземпляра obj у списку, що викликає. Якщо об'єкт не є елементом списку, повертається .1.
5 int lastIndexOf(Object obj
	Повертає індекс останнього екземпляра obj у списку, що викликає. Якщо об'єкт не є елементом списку, повертається .1.
6 ListIterator listIterator( )
	Повертає ітератор на початок списку, що викликає.
7 ListIterator listIterator(int index)
	Повертає ітератор у список, що викликає, який починається із зазначеного індексу.
8 Object remove(int index)
	Видаляє елемент, що знаходиться на позиції index, з списку, що викликає, і повертає видалений елемент. Отриманий перелік ущільнюється. Тобто, індекси наступних елементів зменшуються на одиницю.
9 Object set(int index, Object obj)
	Привласнює obj до розташування, зазначеним index'ом у списку, що викликає.
10 List subList(int start, int end)
	Повертає список, що містить елементи від початку до кінця .1 у списку, що викликає. Елементи у списку, що повертається, також посилаються на викликаючий об'єкт.
	
	Приклад
Вищезгаданий інтерфейс було реалізовано у різних класах Java як ArrayList чи LinkedList тощо. Нижче наведено приклад, який пояснює кілька методів з різних реалізацій класів з наведених вище методів колекцій:

import java.util.*;

public class CollectionsDemo {

   public static void main(String[] args) {

      List a1 = новий ArrayList();

      a1.add("Зоря");

      a1.add("Марк");

      a1.add("Айан");

      System.out.println("ArrayList Елементи");

      System.out.print("\t" + a1);

      List l1 = New LinkedList();

      l1.add("Зоря");

      l1.add("Марк");

      l1.add("Айан");

      System.out.println();

      System.out.println("LinkedList Елементи");

      System.out.print("\t" + l1);

   }

}
Отримаємо наступний результат:

ArrayList Елементи

[Зоря, Марк, Айан]

LinkedList Елементи

[Зоря, Марк, Айан]



		~Інтерфейс Set
Інтерфейс Set - це Collection, який не може містити повторювані елементи. Він моделює математичну установку абстракції.

Інтерфейс Set в Java містить тільки методи, успадковані з Collection, і додає обмеження, яке забороняє повторювані елементи.

Set також додає сильніший договір на поведінку операцій equals і hashCode, дозволяючи порівнювати екземпляри Set, навіть якщо їх типи реалізації різняться. Методи, оголошені Set, наведені у таблиці:

Методи
№ Методи та опис
1 add( )
	Додає об'єкт до колекції.
2 clear( )
	Видаляє всі об'єкти з колекції.
3 contains( )
	Повертає true, якщо вказаний об'єкт є елементом колекції.
4 isEmpty( )
	Повертає true, якщо колекції немає елементів.
5 iterator( )
	Повертає об'єкт Iterator для колекції, який може бути використаний для отримання об'єкта
6 remove( )
	Видаляє вказаний об'єкт із колекції.
7 size( )
	Повертає кількість елементів у колекції.

	Приклад
Java інтерфейс Set має свою реалізацію в різних класах як HashSet, TreeSet, LinkedHashSet. Нижче наведено приклад, який пояснює функціональність Set:

import java.util.*;

public class SetDemo {

public static void main(String args[]) {

int count[] = {34, 22,10,60,30,22};

Set set = новий HashSet();

try {

for(int i = 0; i < 5; i++) {

set.add(count[i]);

}

System.out.println(set);

TreeSet sortedSet = новий TreeSet(set);

System.out.println("Відсортований список:");

System.out.println(sortedSet);

System.out.println("Перший елемент набору: "+ (Integer)sortedSet.first());

System.out.println("Останній елемент набору: "+ (Integer)sortedSet.last());

}

catch (Exception e) {}

}

}
Отримаємо наступний результат:

[34, 22, 10, 60, 30]

Список відсортованих:

[10, 22, 30, 34, 60]

Перший елемент: 10

Останній елемент набору: 60



		~Клас LinkedList
Клас LinkedList Java розширює AbstractSequentialList і реалізує інтерфейс List. Він надає структуру даних пов'язаних списків.

		Конструктори
Нижче наведені конструктори, які підтримуються класом LinkedList.

№ 	Конструктор та опис
1 	LinkedList( )
	Цей конструктор створює порожній пов'язаний список.
2 	LinkedList(Collection c)
	Цей конструктор створює пов'язаний перелік, який ініціалізується елементами колекції с.

	Методи
Крім застосування методів, успадкованих від батьківських класів, LinkedList визначає такі методи:

№ 	та опис
1 	void add(int index, Object element)
	Вставляє вказаний елемент у вказаний вказівник позиції в цьому списку. Викликає IndexOutOfBoundsException, якщо зазначений індекс виходить за допустимі межі (index < 0 || index > size()).
2 	boolean add(Object o)
	Додає цей елемент до кінця цього списку.
3 	boolean addAll(Collection c)
	Додає всі елементи у вказаній колекції до кінця цього списку в тому порядку, в якому вони повертаються ітератором вказаної колекції. Викидає NullPointerException, якщо вказана колекція має значення null (нуль).
4 	boolean addAll(int index, Collection c)
	Вставляє всі елементи вказаної колекції до цього списку, починаючи з цієї позиції. Викликає NullPointerException, якщо вказана колекція має значення null (нуль).
5 	void addFirst(Object o)
	Вставляє цей елемент на початок цього списку.
6 	void addLast(Object o)
	Додає цей елемент до кінця цього списку.
7 	clear()
	Видаляє всі елементи цього списку.
8 	Object clone()
	Повертає дрібну копію цього LinkedList.
9 	boolean contains(Object o)
	Повертає true, якщо цей список містить цей елемент. Якщо точніше, то повертає true тоді і тільки тоді, коли цей список містить хоча б один елемент e такий, що (o==null ? e==null : o.equals(e)).
10 	Object get(int index)
	Повертає елемент у зазначеній позиції у цьому списку. Викликає IndexOutOfBoundsException, якщо зазначений індекс виходить за допустимі межі (index < 0 || index >= size()).
11 	Object getFirst()
	Повертає перший елемент у цьому списку. Викликає виняток NoSuchElementException, якщо цей список порожній.
12 	Object getLast()
	Повертає останній елемент у цьому списку. Викликає виняток NoSuchElementException, якщо цей список порожній.
13 	int indexOf(Object o)
	Повертає індекс у цьому списку першої згадки зазначеного елемента або -1, якщо список не містить цього елемента.
14 	int lastIndexOf(Object o)
	Повертає індекс у цьому списку останньої згадки вказаного елемента або -1, якщо список не містить цього елемента.
15 	ListIterator listIterator(int index)
	Повертає список-ітератор елементів у цьому списку (у правильній послідовності), починаючи із зазначеної позиції у списку. Викликає IndexOutOfBoundsException, якщо цей індекс виходить за межі діапазону (index < 0 || index >= size()).
16 	Object remove(int index)
	Видаляє елемент у зазначеній позиції у цьому списку. Викликає виняток NoSuchElementException, якщо цей список порожній.
17 	boolean remove(Object o)
	Видаляє першу згадку вказаного елемента в цьому списку. Викликає виняток NoSuchElementException, якщо цей список порожній. Викликає IndexOutOfBoundsException, якщо цей індекс виходить за межі діапазону (index < 0 || index >= size()).
18 	Object removeFirst()
	Видаляє та повертає перший елемент із цього списку. Викидає виняток NoSuchElementException, якщо цей список порожній.
19 	Object removeLast()
	Видаляє та повертає останній елемент із цього списку. Викликає виняток NoSuchElementException, якщо цей список порожній.
20 	Object set(int index, Object element)
	Замінює елемент у зазначеній позиції у цьому списку вказаним елементом. Викликає IndexOutOfBoundsException, якщо цей індекс виходить за межі діапазону (index < 0 || index >= size()).
21 	int size()
	Повертає кількість елементів у цьому списку.
22 	Object[] toArray()
	Повертає масив, що містить усі елементи у цьому списку у правильному порядку. Викидає NullPointerException, якщо цей масив дорівнює null (нулю).
23 	Object[] toArray(Object[] a)
	Повертає масив, що містить усі елементи у цьому списку у правильному порядку; Тип виконання масива, що повертається - тип зазначеного масиву.

	Приклад
Наступна програма показує реалізацію деяких методів, що підтримуються LinkedList в Java:

import java.util.*;
public class LinkedListDemo {

   public static void main(String args[]) {
      // Створюємо LinkedList
      LinkedList ll = New LinkedList();
      
      // Додаємо елементи до LinkedList
      ll.add("F");
      ll.add("B");
      ll.add("D");
      ll.add("E");
      ll.add("C");
      ll.addLast("Z");
      ll.addFirst("A");
      ll.add(1, "A2");
      System.out.println("Споконвічний зміст ll:" + ll);

      // Видаляємо елементи з LinkedList
      ll.remove("F");
      ll.remove(2);
      System.out.println("Зміст ll після видалення: " + ll);

	// Видаляємо перший та останній елементи
       ll.removeFirst();
       ll.removeLast();
       System.out.println("ll після видалення першого та останнього: " + ll);

       // Отримуємо та встановлюємо значення
       Object val = ll.get(2);
       ll.set(2, (String) val + "Змінено");
       System.out.println("ll після зміни: " + ll);
    }
}

Отримаємо наступний результат:

Початковий зміст ll: [A, A2, F, B, D, E, C, Z]
Зміст ll після видалення: [A, A2, D, E, C, Z]
ll після видалення першого та останнього: [A2, D, E, C]
ll після зміни: [A2, D, E Змінено, C]



		~Клас ArrayList
Клас ArrayList Java розширює AbstractList і реалізує інтерфейс List . ArrayList підтримує динамічні масиви, які можуть зростати в міру потреби.

Стандартні масиви Java мають фіксовану довжину. Після створення масивів вони не можуть рости або скорочуватися, а це означає, що ви повинні заздалегідь знати, скільки елементів утримуватиме масив.

Списки масивів створюються з початковим розміром. Коли цей розмір перевищено, колекція автоматично зростає. Коли видаляються об'єкти, масив може бути скорочений.

		Конструктори
Нижче наведено список конструкторів, які надають клас ArrayList.

№	Конструктор та опис
1	ArrayList( )
	Цей конструктор створює порожній список масивів.
2	ArrayList(Collection c)
	Цей конструктор будує перелік масивів, який ініціалізується елементами колекції c .
3	ArrayList(int capacity)
	Цей конструктор створює список масивів із зазначеної початкової capacity. Місткість – це розмір базового масиву, який використовується для зберігання елементів. Місткість зростає автоматично в міру додавання елементів до списку масивів.

		Методи
Крім методів, успадкованих від батьківських класів, ArrayList визначає такі методи:

№	Метод та опис
1	void add(int index, Object element)
	Вставляє вказаний елемент у вказаний індекс позиції у цьому списку. Викидає IndexOutOfBoundsException, якщо зазначений індекс виходить за допустимі межі (index < 0 || index > size()).
2	boolean add(Object o)
	Додає вказаний елемент до кінця цього списку.
3	boolean addAll(Collection c)
	Додає всі елементи у вказаній колекції до кінця цього списку в порядку, в якому вони повертаються ітератором вказаної колекції. Викликає NullPointerException, якщо вказана колекція має значення null (нульова).
4	boolean addAll(int index, Collection c)
	Вставляє всі елементи вказаної колекції в цей список, починаючи з вказаної позиції. Викликає NullPointerException, якщо вказана колекція має значення null.
5	void clear()
	Видаляє всі елементи цього списку.
6	Object clone()
	Повертає неглибоку копію цього масиву.
7	boolean contains(Object o)
	Повертає true, якщо список містить зазначений елемент. Якщо точніше, то повертає true тоді і тільки тоді, коли цей список містить хоча б один елемент e такий, що (o==null ? e==null : o.equals(e)).
8	void ensureCapacity(int minCapacity)
	Збільшує ємність цього екземпляра ArrayList, якщо це необхідно, щоб гарантувати, що він може утримувати принаймні кількість елементів, заданих аргументом мінімальної ємності.
9	Object get(int index)
	Повертає елемент у зазначеній позиції у цьому списку. Викликає IndexOutOfBoundsException, якщо зазначений індекс виходить за допустимі межі (index < 0 || index >= size()).
10	int indexOf(Object o)
	Повертає індекс у цьому списку першої згадки зазначеного елемента або -1, якщо List не містить цього елемента.
11	int lastIndexOf(Object o)
	Повертає індекс у цьому списку останньої згадки зазначеного елемента або -1, якщо List не містить цього елемента.
12	Object remove(int index)
	Видаляє елемент у зазначеній позиції у цьому списку. Викликає IndexOutOfBoundsException, якщо індекс виходить за допустимі межі (index < 0 || index >= size()).
13	protected void removeRange(int fromIndex, int toIndex)
	Видаляє з цього списку всі елементи, індекс яких знаходиться між fromIndex, включно, і toIndex, виключно.
14	Object set(int index, Object element)
	Замінює елемент у зазначеній позиції у цьому списку зазначеним елементом. Викликає IndexOutOfBoundsException, якщо зазначений індекс виходить за допустимі межі (index < 0 || index >= size()).
15	int size()
	Повертає кількість елементів у цьому списку.
16	Object[] toArray()
	Повертає масив, що містить усі елементи в цьому списку у правильному порядку. Викликає NullPointerException, якщо вказаний масив дорівнює null (нульовий).
17	Object[] toArray(Object[] a)
	Повертає масив, що містить усі елементи у цьому списку у правильному порядку; Тип виконання масива, що повертається - тип зазначеного масиву.
18	void trimToSize()
	Обрізає ємність цього екземпляра ArrayList до його поточних розмірів.

	Приклад
Наступна демонструє роботу кількох методів, підтримуваних ArrayList Java:

import java.util.*;
public class ArrayListDemo {

   public static void main(String args[]) {
      // Ініціалізація ArrayList
      // Створюємо ArrayList
      ArrayList al = new ArrayList();
      System.out.println("Спочатковий розмір al: " + al.size());

      // Додаємо елементи до ArrayList
      al.add("C");
      al.add("A");
      al.add("E");
      al.add("B");
      al.add("D");
      al.add("F");
      al.add(1, "A2");
      System.out.println("Розмір al після додавання: " + al.size());

      // Виводимо на екран елементи ArrayList
      System.out.println("Вміст al:" + al);

      // Видаляємо елементи з ArrayList
      al.remove("F");
      al.remove(2);
      System.out.println("Розмір al після видалення: " + al.size());
      System.out.println("Вміст al:" + al);
   }
}
Отримаємо наступний результат:

Початковий розмір al: 0
Розмір al після додавання: 7
Вміст al: [C, A2, A, E, B, D, F]
Розмір al після видалення: 5
Вміст al: [C, A2, E, B, D]